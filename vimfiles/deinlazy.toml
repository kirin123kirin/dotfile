[[plugins]]
repo = 'Shougo/neomru.vim'
on_if = 1
hook_add = '''
  let g:neomru#update_interval = 300
 " let g:neomru#file_mru_path = g:cache_home . '/neomru/file'
  "let g:neomru#directory_mru_path = g:cache_home . '/neomru/directory'
'''

[[plugins]]
repo = 'Shougo/vimproc'
merged = 0
hook_add = '''
	if dein#util#_is_windows()
	  let g:vimproc#download_windows_dll = 1
	  let s:vimproc_dll_basename = has('win64') ?
	        \ 'vimproc_win64.dll' : 'vimproc_win32.dll'
	elseif dein#util#_is_cygwin()
	  let s:vimproc_dll_basename = 'vimproc_cygwin.dll'
	elseif dein#util#_is_mac()
	  let s:vimproc_dll_basename = 'vimproc_mac.so'
	elseif glob('/lib*/ld-linux*64.so.2', 1) != ''
	  let s:vimproc_dll_basename = 'vimproc_linux64.so'
	elseif glob('/lib*/ld-linux*.so.2', 1) != ''
	  let s:vimproc_dll_basename = 'vimproc_linux32.so'
	elseif system('uname -s') =~? '^.\+BSD\n$'
	  let s:vimproc_dll_basename = system(
	        \ 'uname -sm | tr "[:upper:]" "[:lower:]"'
	        \ .' | sed -e "s/ /_/" | xargs -I "{}" echo "vimproc_{}.so"')[0 : -2]
	else
	  let s:vimproc_dll_basename = 'vimproc_unix.so'
	endif

	let s:vimproc_dll = get(g:, 'vimproc#dll_path', dein#get('vimproc').path . '/lib/'. s:vimproc_dll_basename)

	if !filereadable(s:vimproc_dll)
	  call dein#call_hook('post_update')
	  call dein#build('vimproc')
	endif
'''
hook_post_update = '''
	if dein#util#_is_windows()
	  let cmd = 'tools\\update-dll-mingw'
	elseif dein#util#_is_cygwin()
	  let cmd = 'make -f make_cygwin.mak'
	  if $MSYSTEM == "MINGW32" || $MSYSTEM == "MINGW64"
	    let cmd = "MSYSTEM=MSYS bash --login -c 'cd " . g:dein#plugin.path . ";" . cmd . "'"
	  endif
	elseif executable('gmake')
	  let cmd = 'gmake'
	else
	  let cmd = 'make'
	endif
	let g:dein#plugin.build = cmd
'''


[[plugins]]
repo = 'Shougo/neoyank.vim'
on_if = 1
on_event = 'TextYankPost'
on_source = ['unite.vim', 'denite.nvim']

[[plugins]]
repo = 'Shougo/echodoc.vim'
on_event = 'CompleteDone'
hook_source = 'call echodoc#enable()'

[[plugins]]
repo = 'Shougo/neocomplete.vim'
if = "has('lua')"
on_event = 'InsertEnter'
hook_source = '''
	let g:neocomplete#enable_at_startup = 1
	let g:neocomplete#disable_auto_complete = 0

	let g:neocomplete#enable_smart_case = 1
	let g:neocomplete#enable_camel_case = 1
	let g:neocomplete#auto_complete_delay = 30

	let g:neocomplete#enable_fuzzy_completion = 1

	let g:neocomplete#auto_completion_start_length = 2
	let g:neocomplete#manual_completion_start_length = 0
	let g:neocomplete#min_keyword_length = 3

	let g:neocomplete#enable_auto_select = 1

	let g:neocomplete#enable_auto_delimiter = 1
	let g:neocomplete#max_list = 100
	if !exists('g:neocomplete#sources#omni#input_patterns')
	  let g:neocomplete#sources#omni#input_patterns = {}
	endif

	let g:marching_enable_neocomplete = 1

	let g:neocomplete#sources#omni#input_patterns.python =
	      \ '[^. *\t]\.\w*\|\h\w*'

	" Define keyword pattern.
	if !exists('g:neocomplete#keyword_patterns')
	  let g:neocomplete#keyword_patterns = {}
	endif
	let g:neocomplete#keyword_patterns._ = '\h\k*(\?'
	let g:neocomplete#keyword_patterns.rst =
	      \ '\$\$\?\w*\|[[:alpha:]_.\\/~-][[:alnum:]_.\\/~-]*\|\d\+\%(\.\d\+\)\+'

	call neocomplete#custom#source('look', 'min_pattern_length', 4)
	call neocomplete#custom#source('_', 'converters',
	      \ ['converter_add_paren', 'converter_remove_overlap',
	      \  'converter_delimiter', 'converter_abbr'])

	" mappings."{{{
	" <C-f>, <C-b>: page move.
	inoremap <expr><C-f>  pumvisible() ? "\<PageDown>" : "\<Right>"
	inoremap <expr><C-b>  pumvisible() ? "\<PageUp>"   : "\<Left>"
	" <C-h>, <BS>: close popup and delete backword char.
	" inoremap <expr> <C-h> neocomplete#smart_close_popup()."\<C-h>"
	inoremap <expr> <BS> neocomplete#smart_close_popup()."\<C-h>"
	" <C-n>: neocomplete.
	inoremap <expr> <C-n>  pumvisible() ? "\<C-n>" : "\<C-x>\<C-u>\<C-p>\<Down>"
	" <C-p>: keyword completion.
	inoremap <expr> <C-p>  pumvisible() ? "\<C-p>" : "\<C-p>\<C-n>"
	inoremap <expr> '  pumvisible() ? "\<C-y>" : "'"

	" <CR>: close popup and save indent.
	inoremap <silent> <CR> <C-r>=<SID>my_cr_function()<CR>
	function! s:my_cr_function() abort
	  return neocomplete#smart_close_popup() . "\<CR>"
	endfunction

	" <TAB>: completion.
	inoremap <silent><expr> <TAB>
	      \ pumvisible() ? "\<C-n>" :
	      \ <SID>check_back_space() ? "\<TAB>" :
	      \ neocomplete#start_manual_complete()
	function! s:check_back_space() abort "{{{
	  let col = col('.') - 1
	  return !col || getline('.')[col - 1]  =~ '\s'
	endfunction"}}}
	" <S-TAB>: completion back.
	inoremap <expr><S-TAB>  pumvisible() ? "\<C-p>" : "\<C-h>"
	"}}}
'''

[[plugins]]
repo = 'Shougo/neosnippet.vim'
#depends = ['neosnippet-snippets', 'context_filetype.vim']
on_event = 'InsertCharPre'
on_ft = 'snippet'
hook_source = '''
	imap <silent>L     <Plug>(neosnippet_jump_or_expand)
	smap <silent>L     <Plug>(neosnippet_jump_or_expand)
	xmap <silent>L     <Plug>(neosnippet_expand_target)

	let g:neosnippet#enable_snipmate_compatibility = 1
	let g:neosnippet#enable_completed_snippet = 1
	let g:neosnippet#expand_word_boundary = 1
'''

[[plugins]]
repo = 'Shougo/unite.vim'
hook_add = '''
  let g:unite_split_rule = 'botright'
  let g:unite_source_bookmark_directory = g:conf_dir . "/bookmark"
'''
hook_source = '''
	" default browser Vimfiler
	call unite#custom#default_action('directory' , 'cd')

	" default file tabopen
	call unite#custom#default_action('file' , 'tabdrop')
'''

[[plugins]]
repo = 'Shougo/denite.nvim'
on_cmd = 'Denite'
hook_add = '''
  nnoremap <silent> <C-y>
        \ :<C-u>Denite -buffer-name=register
        \ register<CR>" neoyank<CR>
  xnoremap <silent> <C-y>
        \ :<C-u>Denite -default-action=replace -buffer-name=register
        \ register<CR>" neoyank<CR>

  nnoremap <silent> * :<C-u>DeniteCursorWord -buffer-name=search
        \ -mode=normal line<CR>
  nnoremap <silent> [Window]s :<C-u>Denite file_point file_old
        \ `finddir('.git', ';') != '' ? 'file_rec/git' : 'file_rec'`<CR>

  nnoremap <silent><expr> tt  &filetype == 'help' ?  "g\<C-]>" :
        \ ":\<C-u>DeniteCursorWord -buffer-name=tag -immediately
        \  tag:include\<CR>"
  nnoremap <silent><expr> tp  &filetype == 'help' ?
        \ ":\<C-u>pop\<CR>" : ":\<C-u>Denite -mode=normal jump\<CR>"

  nnoremap <silent> [Window]n :<C-u>Denite dein<CR>
  nnoremap <silent> [Window]g :<C-u>Denite ghq<CR>
  nnoremap <silent> ;g :<C-u>Denite -buffer-name=search
        \ -no-empty -mode=normal grep<CR>
  nnoremap <silent> n :<C-u>Denite -buffer-name=search
        \ -resume -mode=normal -refresh<CR>
  nnoremap <silent> ft :<C-u>Denite filetype<CR>
  nnoremap <silent> <C-t> :<C-u>Denite
        \ -select=`tabpagenr()-1` -mode=normal deol<CR>
  nnoremap <silent> <C-k> :<C-u>Denite -mode=normal change jump<CR>

  nnoremap <silent> [Space]gs :<C-u>Denite gitstatus<CR>
  nnoremap <silent> <F8>
        \ :<C-u>Denite command_history<CR>

	" gamy
	nmap <C-e> :<C-u>Denite directory_rec 
	nmap <silent> <C-f> :<C-u>Denite file_rec<CR>
	nmap <silent> <F3>  :<C-u>Denite line<CR>
	nmap <silent> <C-F3>  :<C-u>Denite grep<CR>
	nmap <silent> <S-F3>:<C-u>DeniteCursorWord grep<CR>
	nmap <silent> <C-h> :<C-u>Denite file_mru<CR>
	"nmap <silent> <F8>  :<C-u>Denite -resume<CR>
	nmap <silent> <F9>  :<C-N>Denite -resume -immediately -select=+1<CR>
	nmap <silent> <F10> :<C-P>Denite -resume -immediately -select=-1<CR>

'''
hook_post_source = '''
	if executable('rg')
	  call denite#custom#var('file_rec', 'command',
	        \ ['rg', '--files', '--glob', '!.git'])
	  " call denite#custom#var('grep', 'command', ['rg', '--threads', '1'])
	  " call denite#custom#var('grep', 'recursive_opts', [])
	  " call denite#custom#var('grep', 'final_opts', [])
	  " call denite#custom#var('grep', 'separator', ['--'])
	  " call denite#custom#var('grep', 'default_opts',
	  "       \ ['--vimgrep', '--no-heading'])
	else
	  call denite#custom#var('file_rec', 'command',
	        \ ['pt', '--follow', '--nocolor', '--hidden', '--nogroup', '-g', ''])
	endif

	call denite#custom#source('file_old', 'matchers',
	      \ ['matcher_fuzzy', 'matcher_project_files'])
	if has('nvim')
	  call denite#custom#source('file_rec,grep', 'matchers',
	        \ ['matcher_cpsm'])
	endif
	call denite#custom#source('file_old', 'converters',
	      \ ['converter_relative_word'])

	call denite#custom#map('insert', '<C-j>',
	      \ '<denite:move_to_next_line>', 'noremap')
	call denite#custom#map('insert', '<C-k>',
	      \ '<denite:move_to_previous_line>', 'noremap')
	call denite#custom#map('insert', "'",
	      \ '<denite:move_to_next_line>', 'noremap')
	call denite#custom#map('normal', 'r',
	      \ '<denite:do_action:quickfix>', 'noremap')

	call denite#custom#alias('source', 'file_rec/git', 'file_rec')
	call denite#custom#var('file_rec/git', 'command',
	      \ ['git', 'ls-files', '-co', '--exclude-standard'])

	call denite#custom#option('default', 'prompt', '>')
	" call denite#custom#option('default', 'short_source_names', v:true)
	call denite#custom#option('default', {
	      \ 'prompt': '>', 'short_source_names': v:true
	      \ })

	"call denite#custom#var('menu', 'menus', s:menus)

	call denite#custom#filter('matcher_ignore_globs', 'ignore_globs',
	      \ [ '.git/', '.svn/', '.ropeproject/', '__pycache__/',
	      \   'venv/', 'images/', '*.min.*', 'img/', 'fonts/'])

'''

[[plugins]]
repo = 'Shougo/context_filetype.vim'

[[plugins]]
repo = 'Shougo/vimfiler.vim'
#depends = 'unite.vim'
on_map = {n = '<Plug>'}
on_if = "isdirectory(bufname('%'))"
hook_add = '''
	autocmd VimEnter * VimFiler -buffer-name=explorer -split -simple -winwidth=45 -toggle -no-quit
	nnoremap <F2> :VimFiler -buffer-name=explorer -split -simple -winwidth=45 -toggle -no-quit<Cr>
	nnoremap <S-F2> :VimFilerDouble -buffer-name=commander -simple -no-quit<Cr>
'''
hook_source = '''
	call vimfiler#custom#profile('default', 'context', {
	      \ 'safe' : 0,
	      \ 'auto_expand' : 1,
	      \ 'parent' : 0,
	      \ })

	let g:vimfiler_as_default_explorer = 1
	let g:vimfiler_enable_auto_cd = 1
	if IsWindows()
		let g:vimfiler_detect_drives = [
		      \ 'C:/', 'D:/', 'E:/', 'F:/', 'G:/', 'H:/', 'I:/',
		      \ 'J:/', 'K:/', 'L:/', 'M:/', 'N:/', 'Y:', 'Z:']
		" Use trashbox.
		let g:unite_kind_file_use_trashbox = 1
	endif
	" Like Textmate icons.
	let g:vimfiler_tree_leaf_icon = ' '
	let g:vimfiler_tree_opened_icon = '-'
	let g:vimfiler_tree_closed_icon = '+'
	let g:vimfiler_file_icon = ' '
	let g:vimfiler_readonly_file_icon = '!'
	let g:vimfiler_marked_file_icon = '*'

	autocmd MyAutoCmd FileType vimfiler call s:vimfiler_my_settings()
	function! s:vimfiler_my_settings() abort "{{{
		nmap <buffer> <Tab> <Plug>(vimfiler_switch_to_other_window)
	endfunction"}}}
	
	autocmd FileType vimfiler nmap <buffer> <CR> <Plug>(vimfiler_expand_or_edit)
'''

[[plugins]]
repo = 'Shougo/vimshell.vim'
on_map = {n = '<Plug>'}
hook_add = 'nmap [Space]s  <Plug>(vimshell_switch)'
hook_source = '''
	let g:vimshell_user_prompt = ''
	let g:vimshell_right_prompt = 'fnamemodify(getcwd(), ":~")'
	let g:vimshell_prompt = empty($USER) ? $USERNAME.'% ' : $USER.'% '
	let g:vimshell_split_command = ''
	let g:vimshell_enable_transient_user_prompt = 1
	let g:vimshell_force_overwrite_statusline = 2

	autocmd MyAutoCmd FileType vimshell call s:vimshell_settings()
	function! s:vimshell_settings() abort
	  if !IsWindows()
	    " Use zsh history.
	    let g:vimshell_external_history_path = expand('~/.zsh-history')
	  endif

	  inoremap <buffer><expr>'  pumvisible() ? "\<C-y>" : "'"
	  imap <buffer><BS>  <Plug>(vimshell_another_delete_backward_char)
	  imap <buffer><C-h>  <Plug>(vimshell_another_delete_backward_char)

	  call vimshell#altercmd#define('g', 'git')
	  call vimshell#set_alias('.', 'source')

	  call vimshell#hook#add('chpwd', 'my_chpwd', s:vimshell_hooks.chpwd)
	  call deoplate#disable()
	endfunction

	let s:vimshell_hooks = {}
	function! s:vimshell_hooks.chpwd(args, context) abort
	  call vimshell#execute((len(split(glob('*'), '\n')) < 100) ?
	        \ 'ls' : 'echo "Many files."')
	endfunction
'''

[[plugins]]
repo = 'Shougo/junkfile.vim'
on_source = 'denite.vim'
hook_add = '''
  nnoremap <silent> [Window]e :<C-u>Denite junkfile:new junkfile<CR>
'''

[[plugins]]
repo = 'Shougo/neco-vim'
on_ft = 'vim'

[[plugins]]
repo = 'Shougo/neoinclude.vim'
on_if = 1

[[plugins]]
repo = 'kana/vim-niceblock'
on_map = {x = '<Plug>'}
hook_add = '''
  xmap I  <Plug>(niceblock-I)
  xmap A  <Plug>(niceblock-A)
'''

[[plugins]]
repo = 'vim-jp/vital.vim'

[[plugins]]
repo = 'ctrlpvim/ctrlp.vim'

[[plugins]]
repo = 'thinca/vim-fontzoom'
on_map = {n = '<Plug>'}
hook_add = '''
  nmap + <Plug>(fontzoom-larger)
  nmap _ <Plug>(fontzoom-smaller)
'''

[[plugins]]
repo = 'thinca/vim-qfreplace'
on_ft = ['unite', 'qf']
hook_source = '''
  autocmd MyAutoCmd FileType qf nnoremap <buffer> r :<C-u>Qfreplace<CR>
'''

[[plugins]]
repo = 'thinca/vim-ref'
on_map = {n = '<Plug>'}
hook_source = '''
  let g:ref_cache_dir = expand('$CACHE/ref')
  let g:ref_use_vimproc = 1
  if IsWindows()
    let g:ref_refe_encoding = 'cp932'
  endif

  autocmd MyAutoCmd FileType ref call s:ref_my_settings()
  function! s:ref_my_settings() abort "{{{
    " Overwrite settings.
    nmap <buffer> [Tag]t  <Plug>(ref-keyword)
    nmap <buffer> [Tag]p  <Plug>(ref-back)
    nnoremap <buffer> <TAB> <C-w>w
  endfunction"}}}
'''

[[plugins]]
repo = 'tyru/caw.vim'
on_map = {nx = '<Plug>'}
hook_add = '''
  function! InitCaw() abort
    if !&l:modifiable
      silent! nunmap <buffer> gc
      silent! xunmap <buffer> gc
      silent! nunmap <buffer> gcc
      silent! xunmap <buffer> gcc
    else
      nmap <buffer> gc <Plug>(caw:prefix)
      xmap <buffer> gc <Plug>(caw:prefix)
      nmap <buffer> gcc <Plug>(caw:hatpos:toggle)
      xmap <buffer> gcc <Plug>(caw:hatpos:toggle)
    endif
  endfunction
  autocmd MyAutoCmd FileType * call InitCaw()
  call InitCaw()
'''

[[plugins]]
repo = 'tyru/open-browser.vim'
on_if = 1
hook_add = '''
	let g:netrw_nogx = 1
	nmap <silent> gx <Plug>(openbrowser-smart-search)
	vmap <silent> gx <Plug>(openbrowser-smart-search)
	vmap <silent> gs <Plug>(openbrowser-search)
    nmap <silent> gs <Plug>(openbrowser-search)
'''

[[plugins]]
repo = 'eagletmt/neco-ghc'
on_ft = 'haskell'
external_commands = 'ghc-mod'

[[plugins]]
repo = 'rhysd/accelerated-jk'
on_map = {n = '<Plug>'}
hook_add = '''
  nmap <silent>j <Plug>(accelerated_jk_gj)
  nmap <silent>k <Plug>(accelerated_jk_gk)
'''

[[plugins]]
repo = 'aharisu/vim-gdev'
on_ft = 'scheme'

[[plugins]]
repo = 'fatih/vim-go'
on_ft = 'go'

[[plugins]]
repo = 'rhysd/vim-operator-surround'
#depends = 'vim-operator-user'
on_map = {n = '<Plug>'}
hook_add = '''
  nmap <silent>sa <Plug>(operator-surround-append)a
  nmap <silent>sd <Plug>(operator-surround-delete)a
  nmap <silent>sr <Plug>(operator-surround-replace)a
  nmap <silent>sc <Plug>(operator-surround-replace)a
'''

[[plugins]]
repo = 'kannokanno/previm'
on_ft = ['markdown', 'rst', 'mkd', 'md']
on_cmd = 'PrevimOpen'
#depends = 'open-browser.vim'
hook_post_source = '''
let g:previm_open_cmd = g:default_browser
'''

[[plugins]]
repo = 'osyo-manga/vim-jplus'
on_map = {n = '<Plug>'}
hook_add = '''
  nmap J <Plug>(jplus)
'''

[[plugins]]
repo = 'davidhalter/jedi-vim'
if = "!has('nvim')"
on_ft = 'python'
hook_source = '''
  let g:jedi#completions_enabled = 0
  let g:jedi#auto_vim_configuration = 0
  let g:jedi#smart_auto_mappings = 0
  let g:jedi#show_call_signatures = 0
'''

[[plugins]]
repo = 'rust-lang/rust.vim'
on_ft = 'rust'

[[plugins]]
repo = 'rhysd/rust-doc.vim'
on_ft = 'rust'

[[plugins]]
repo = 'artur-shaik/vim-javacomplete2'
on_ft = 'java'
hook_source = '''
  autocmd MyAutoCmd FileType java setlocal omnifunc=javacomplete#Complete
'''

[[plugins]]
repo = 'lambdalisue/vim-findent'

[[plugins]]
repo = 'kana/vim-smartchr'
on_event = 'InsertCharPre'
hook_source = '''
  inoremap <expr> , smartchr#one_of(', ', ',')
  inoremap <expr> =
        \ search('\(&\<bar><bar>\<bar>+\<bar>-\<bar>/\<bar>>\<bar><\) \%#', 'bcn')? '<bs>= '
        \ : search('\(*\<bar>!\)\%#', 'bcn') ? '= '
        \ : smartchr#one_of(' = ', '=', ' == ')
  augroup MyAutoCmd
    " Substitute .. into -> .
    autocmd FileType c,cpp inoremap <buffer> <expr> .
          \ smartchr#loop('.', '->', '...')
    autocmd FileType vim inoremap <buffer> <expr> .
          \ smartchr#loop('.', ' . ', '..', '...')
    autocmd FileType lisp,scheme,clojure inoremap <buffer> <expr> = =

    autocmd FileType haskell,int-ghci
          \ inoremap <buffer> <expr> + smartchr#loop('+', ' ++ ')
          \| inoremap <buffer> <expr> - smartchr#loop('-', ' -> ', ' <- ')
          \| inoremap <buffer> <expr> $ smartchr#loop(' $ ', '$')
          \| inoremap <buffer> <expr> \ smartchr#loop('\ ', '\')
          \| inoremap <buffer> <expr> : smartchr#loop(':', ' :: ', ' : ')
          \| inoremap <buffer> <expr> . smartchr#loop('.', ' . ', '..')
  augroup END
'''

[[plugins]]
repo = 'tweekmonster/impsort.vim'
on_cmd = 'ImpSort'
hook_source = 'let g:impsort_highlight_imported = 0'

[[plugins]]
repo = 'tweekmonster/helpful.vim'
on_cmd = 'HelpfulVersion'

[[plugins]]
repo = 'Jagua/vim-denite-ghq'
on_source = 'denite.nvim'

[[plugins]]
repo = 'ciaranm/securemodelines'
on_event = 'BufRead'

[[plugins]]
repo = 'rhysd/vim-gfm-syntax'
on_event = 'BufRead'

[[plugins]]
repo = 'machakann/vim-vimhelplint'
on_ft = 'help'
hook_source = '''
  autocmd MyAutoCmd FileType
  \ help nnoremap <silent><buffer> ,r  :<C-u>VimhelpLint!<CR>
'''

[[plugins]]
repo = 'racer-rust/vim-racer'
on_ft = 'rust'
hook_source = '''
  let $RUST_SRC_PATH = expand('~/.multirust/toolchains/'
  \ .'stable-x86_64-unknown-linux-gnu/'
  \ .'lib/rustlib/src/rust/src/')
'''

[[plugins]]
repo = 'thinca/vim-quickrun'
on_map = [['nxo', '<Plug>(quickrun)']]
depends = ['vimproc', 'previm']
hook_add = '''
	let g:quickrun_config = {
	\   "_" : {
	\       "runner" : "vimproc",
	\       "runner/vimproc/updatetime" : 60
	\   },
	\	'html': {
	\		'command' :g:default_browser,
	\		'exec' : '%c %s',
	\		'outputter': 'browser'
	\	}
	\ }	
'''
